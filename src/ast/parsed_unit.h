/*****************************************************************//**
 * @file   parsed_unit.h
 * @brief  Contains ParsedUnit, the result of parsing a single file.
 * A ParsedUnit needs to have access to the global table, which
 * is shared by all ParsedUnits.
 * 
 * @author RPC
 * @date   March 2024
 *********************************************************************/
#ifndef HG_COLT_PARSED_UNIT
#define HG_COLT_PARSED_UNIT

#include "lex/colt_token_buffer.h"
#include "ast/colt_expr_buffer.h"

namespace clt::lng
{
  // Forward declaration
  class ParsedProgram;

  /// @brief Represents the result of parsing a single file
  class ParsedUnit
  {
    /// @brief Contains the global table, and the error reporter
    ParsedProgram& program;
    /// @brief File path of the current unit
    const std::filesystem::path& path;
    /// @brief Contains the parsed lexemes
    TokenBuffer tokens;
    /// @brief Contains the expression
    ExprBuffer exprs;
    /// @brief The file content
    String to_parse{};
    /// @brief The error count generated by this unit
    u32 error_count = 0;
    /// @brief The warning count generated by this unit
    u32 warn_count  = 0;

  public:
    /// @brief The result of parsing a file
    enum ParseResult
      : u8
    {
      /// @brief No errors
      SUCCESS,
      /// @brief Invalid path to parse
      INVALID_PATH,
      /// @brief Could not read all the file
      FILE_ERROR,
      /// @brief Compilation error
      COMP_ERROR
    };

    ParsedUnit(ParsedProgram& program, const std::filesystem::path& path) noexcept
      : program(program), path(path), exprs(program.getTypes()) {}

    /// @brief Parses the current unit
    /// @return The parsing result
    ParseResult parse() noexcept;

    /// @brief Returns the count of warnings generated by this unit
    /// @return The warnings count
    u64 getWarnCount() const noexcept    
    {
      assert_true("parse must called before this method!", to_parse.capacity() != 0);
      return warn_count;
    }
    
    /// @brief Returns the count of errors generated by this unit
    /// @return The errors count
    u64 getErrorCount() const noexcept
    {
      assert_true("parse must called before this method!", to_parse.capacity() != 0);
      return error_count;
    }

    /// @brief Returns the error reporter
    /// @return The error reporter
    const ErrorReporter& getReporter() const noexcept { return program.getReporter(); }
    /// @brief Returns the error reporter
    /// @return The error reporter
    ErrorReporter& getReporter() noexcept { return program.getReporter(); }

    /// @brief Returns the program that is being parsed
    /// @return The program that is being parsed
    const ParsedProgram& getProgram() const noexcept { return program; }
    /// @brief Returns the program that is being parsed
    /// @return The program that is being parsed
    ParsedProgram& getProgram() noexcept { return program; }
    
    /// @brief Returns the token buffer representing the parsed file
    /// @return The token buffer representing the parsed file
    const TokenBuffer& getTokenBuffer() const noexcept { return tokens; }
    /// @brief Returns the token buffer representing the parsed file
    /// @return The token buffer representing the parsed file
    TokenBuffer& getTokenBuffer() noexcept { return tokens; }
    
    /// @brief Returns the expression buffer representing the parsed file
    /// @return The expression buffer representing the parsed file
    const ExprBuffer& getExprBuffer() const noexcept { return exprs; }
    /// @brief Returns the expression buffer representing the parsed file
    /// @return The expression buffer representing the parsed file
    ExprBuffer& getExprBuffer() noexcept { return exprs; }
  };
}

#endif // !HG_COLT_PARSED_UNIT
