/*****************************************************************//**
 * @file   parsed_unit.cpp
 * @brief  Contains the implementation of ParsedUnit.
 * 
 * @author RPC
 * @date   March 2024
 *********************************************************************/
#include "parsed_unit.h"
#include "parsed_program.h"
#include "ast.h"

namespace clt::lng
{
  ParsedUnit::ParsedUnit(ParsedProgram& program, const std::filesystem::path& path) noexcept
    : program(program), path(path), exprs(program.getTypes()) {}

  ParsedUnit::ParsedUnit(ParsedProgram& program, StringView to_parse) noexcept
    : program(program), path(ParsedProgram::EMPTY_PATH), exprs(program.getTypes()), to_parse(to_parse) {}

  ParsedUnit::ParseResult ParsedUnit::parse() noexcept
  {
    assert_true("parse must only be called once!", !isParsed());
    is_parsed = true;
    if (std::error_code err; !std::filesystem::is_regular_file(path, err))
      return ParseResult::INVALID_PATH;

    auto file = String::getFile(path.string().c_str());
    if (file.is_error())
      return ParseResult::FILE_ERROR;
    to_parse = std::move(*file);

    auto& reporter = program.getReporter();
    // Save the error count
    u64 error_c = reporter.getErrorCount();
    u64 warn_c = reporter.getWarnCount();    
    
    // Lexing of the file
    Lex(tokens, reporter, to_parse);
    // Create AST of the file
    MakeAST(*this);
    
    // Count of errors generated by this unit
    error_count = static_cast<u32>(reporter.getErrorCount() - error_c);
    warn_count = static_cast<u32>(reporter.getWarnCount() - warn_c);

    return error_count ? ParseResult::COMP_ERROR : ParseResult::SUCCESS;
  }
  
  const ErrorReporter& ParsedUnit::getReporter() const noexcept
  {
    return program.getReporter();
  }
  
  ErrorReporter& ParsedUnit::getReporter() noexcept
  {
    return program.getReporter();
  }
}