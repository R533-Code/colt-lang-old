/*****************************************************************//**
 * @file   ast.cpp
 * @brief  Contains the implementation of 'ast.h'.
 * 
 * @author RPC
 * @date   April 2024
 *********************************************************************/
#include "ast.h"

namespace clt::lng
{
  void MakeAST(ParsedUnit& unit) noexcept
  {
    if constexpr (isDebugBuild())
    {
        ASTMaker ast = { unit };
    }
  }

  void ASTMaker::panic_consume_semicolon() noexcept
  {
    using enum Lexeme;
    
    // Consume everything till a ';' is hit
    auto tkn = current();
    while (tkn != TKN_EOF && tkn != TKN_SEMICOLON)
    {
      consume_current();
      tkn = current();
    }
  }
  
  void ASTMaker::panic_consume_lparen() noexcept
  {
    using enum Lexeme;
    
    // Consume everything till a ')' is hit
    auto tkn = current();
    while (tkn != TKN_EOF && tkn != TKN_LEFT_PAREN)
    {
      consume_current();
      tkn = current();
    }
  }

  ProdExprToken ASTMaker::parse_primary_literal(TokenRange range) noexcept
  {
    assert_true("Expected literal token!", isLiteralToken(current()));
    //Save literal token
    auto literal_tkn = current();

    //Consume the literal token
    consume_current();
    
    //TODO: add support for string literal
    QWORD_t value = getTokenBuffer().getLiteral(literal_tkn);
    return getExprBuffer().addLiteral(
      range, value, LiteralToBuiltinID(literal_tkn)
    );
  }
  
  ProdExprToken ASTMaker::parse_primary_invalid(TokenRange range) noexcept
  {
    using enum Lexeme;
    
    // The error would have been generated by the lexer
    if (current() == TKN_ERROR)
      consume_current();
    else
      report_current<ERROR>(current_panic, "Expected an expression!");

    return getExprBuffer().addError(range);
  }

  ProdExprToken ASTMaker::parse_primary(bool accepts_conv)
  {
    using enum Lexeme;
    auto depth = addDepth();
    auto range = startRange();

    uninit<ProdExprToken> to_ret;

    // Handles literals (10, 0.5, ...)
    if (isLiteralToken(current()))
      to_ret = parse_primary_literal(range.getRange());
    // Handles unary operators (&, *, -, ...)
    else if (isUnaryToken(current()))
      to_ret = parse_unary();
    // Handles (...)
    else if (current() == TKN_LEFT_PAREN)
      to_ret = parse_parenthesis(&ASTMaker::parse_binary, (u8)0);
    // Handles invalid primary expressions
    else
      to_ret = parse_primary_invalid(range.getRange());    

    //If the primary expression accepts a conversion, check for as/bit_as.
    if (accepts_conv && is_current_one_of(TKN_KEYWORD_bit_as, TKN_KEYWORD_as))
      return parse_conversion(to_ret, range);
    return to_ret;
  }

  ProdExprToken ASTMaker::parse_unary_and(ProdExprToken child, TokenRange range) noexcept
  {
    if (auto pchild = decl_from_read(child); pchild.isValue())
      return getExprBuffer().addAddressOf(range, pchild.getValue());

    report<ERROR>(range, nullptr,
      "Unary '&' can only be applied on a variable!");
    return getExprBuffer().addError(range);
  }

  ProdExprToken ASTMaker::parse_unary_star(ProdExprToken child, TokenRange range) noexcept
  {
    if (!getExprBuffer().getType(child).isAnyOpaquePtr())
    {
      report<ERROR>(range, nullptr,
        "Unary '*' can only be applied on a non-opaque pointer!");
      return getExprBuffer().addError(range);
    }
    else if (!getExprBuffer().getType(child).isAnyPtr())
    {
      report<ERROR>(range, nullptr,
        "Unary '*' can only be applied on pointer types!");
      return getExprBuffer().addError(range);
    }
    return getExprBuffer().addPtrLoad(range, child);
  }

  ProdExprToken ASTMaker::parse_unary()
  {
    using enum Lexeme;
    auto depth = addDepth();
    auto range = startRange();

    uninit<ProdExprToken> to_ret;

    //Save the operator
    Token op = current();
    consume_current(); //consume the unary operator

    //Parse the child expression, without handling conversions:
    // '-5 as i32' is equivalent to '(-5) as i32'
    ProdExprToken child = parse_primary(false);
    if (getExprBuffer().getExpr(child).isError())
      return child;

    switch (op)
    {
    case TKN_PLUS_PLUS:
    case TKN_MINUS_MINUS:
      
      // Handles '+', which are not supported by the language
    break; case TKN_PLUS:
      report<ERROR>(range.getRange(), current_panic, "Unary '+' is not supported!");
      to_ret = getExprBuffer().addError(range.getRange());
      
      // Handles '&', which are usually AddressOf expressions
    break; case TKN_AND:    
      to_ret = parse_unary_and(child, range.getRange());    
      
      // Handles '*', which are usually PtrLoad expressions
    break; case TKN_STAR:
      to_ret = parse_unary_star(child, range.getRange());
    
    break; default:
      //if (!child->type()->supports(TokenToUnary(op)))
      //{
      //  generate<ERROR>(line_state.to_src_info(), &ASTMaker::panic_consume_semicolon,
      //    "'{}' does not support '{}' operator!", type_name(ctx, child->type()), op_symbol); //TESTED
      //  to_ret = Expr::CreateError(ctx, line_state.to_src_info());
      //}
      //else
        to_ret = getExprBuffer().addUnary(range.getRange(), TokenToUnary(op), child);
    }
    return to_ret;
  }
  
  ProdExprToken ASTMaker::consume_propagate(ProdExprToken err) noexcept
  {
    assert_true("Expected an error!", getExprBuffer().getExpr(err).isError());
    (this->*current_panic)();
    return err;
  }

  ProdExprToken ASTMaker::parse_binary(u8 precedence)
  {
    using enum Lexeme;
    auto depth = addDepth();
    auto range = startRange();

    ProdExprToken lhs = parse_primary();
    if (getExprBuffer().getExpr(lhs).isError())
      return consume_propagate(lhs);

    // The binary operators
    Token binary_op = current();
    if (isAssignmentToken(binary_op))
      return parse_assignment(lhs, range);
    if (isComparisonToken(binary_op))
      return parse_comparison(lhs, range);

    //The current operator's precedence
    u8 op_precedence = OpPrecedence(binary_op);
    while (op_precedence > precedence)
    {
      //Consume the operator
      consume_current();
      //Recurse: 10 + 5 + 8 -> (10 + (5 + 8))
      ProdExprToken rhs = parse_binary(OpPrecedence(binary_op));
      if (getExprBuffer().getExpr(rhs).isError())
        return rhs;

      if (!isBinaryToken(binary_op))
      {
        report<ERROR>(binary_op, current_panic, "Expected a binary operator!");
        return getExprBuffer().addError(range.getRange());
      }
      else //Pratt's parsing, which allows operators priority
        lhs = getExprBuffer().addBinary(range.getRange(), lhs, TokenToBinary(binary_op), rhs);

      //Update the Token
      binary_op = current();
      //Update precedence
      op_precedence = OpPrecedence(binary_op);
    }

    return lhs;
  }

  ProdExprToken ASTMaker::parse_conversion(ProdExprToken to_conv, const TokenRangeGenerator& range)
  {
    return to_conv;
  }

  ProdExprToken ASTMaker::parse_assignment(ProdExprToken assign_to, const TokenRangeGenerator& range)
  {
    auto panic = scopedSetPanic(&ASTMaker::panic_consume_semicolon);
    return assign_to;
  }

  ProdExprToken ASTMaker::parse_comparison(ProdExprToken lhs, const TokenRangeGenerator& range)
  {
    return lhs;
  }

  OptTok<StmtExprToken> ASTMaker::decl_from_read(ProdExprToken expr) const noexcept
  {
    auto& read = getExprBuffer().getExpr(expr);
    if (!read.isRead())
      return None;
    return read.getExpr<ReadExpr>()->getDecl();
  }  
}