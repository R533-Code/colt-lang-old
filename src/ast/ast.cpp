/*****************************************************************//**
 * @file   ast.cpp
 * @brief  Contains the implementation of 'ast.h'.
 * 
 * @author RPC
 * @date   April 2024
 *********************************************************************/
#include "ast.h"

namespace clt::lng
{
  void MakeAST(ParsedUnit& unit) noexcept
  {
    assert_true("Unit already parsed!", !unit.isParsed());
    // The constructor generates the AST directly
    ASTMaker ast = { unit };
  }  
  
  ProdExprToken ASTMaker::parse_primary_literal(const TokenRangeGenerator& range) noexcept
  {
    assert_true("Expected literal token!", isLiteralToken(current()));
    //Save literal token
    auto literal_tkn = current();

    //Consume the literal token
    consume_current();
    
    //TODO: add support for string literal
    QWORD_t value = getTokenBuffer().getLiteral(literal_tkn);
    return Expr().addLiteral(
      range.getRange(), value, LiteralToBuiltinID(literal_tkn)
    );
  }
  
  ProdExprToken ASTMaker::parse_primary_invalid(const TokenRangeGenerator& range) noexcept
  {
    using enum Lexeme;
    
    // The error would have been generated by the lexer
    if (current() == TKN_ERROR)
      consume_current();
    else
      report_current<ERROR>(current_panic, "Expected an expression!");

    return Expr().addError(range.getRange());
  }

  bool ASTMaker::warnFor(run::OpError err) const noexcept
  {
    assert_true("DIV_BY_ZERO is an error not a warning!", err != run::OpError::DIV_BY_ZERO);
    switch_no_default(err)
    {
      case run::OpError::RET_NAN:
      case run::OpError::WAS_NAN:
        return getWarnFor().constant_folding_nan;
      case run::OpError::SIGNED_OVERFLOW:
      case run::OpError::SIGNED_UNDERFLOW:
        return getWarnFor().constant_folding_signed_ou;
      case run::OpError::UNSIGNED_OVERFLOW:
      case run::OpError::UNSIGNED_UNDERFLOW:
        return getWarnFor().constant_folding_unsigned_ou;
      case run::OpError::SHIFT_BY_GRE_SIZEOF:
        return getWarnFor().constant_folding_invalid_shift;
      case run::OpError::NO_ERROR:
        return false;
    }
  }

  ProdExprToken ASTMaker::parse_primary(bool accepts_conv)
  {
    using enum Lexeme;
    auto depth = addDepth();
    auto range = startRange();

    uninit<ProdExprToken> to_ret;

    // Handles literals (10, 0.5, ...)
    if (isLiteralToken(current()))
      to_ret = parse_primary_literal(range);
    // Handles unary operators (&, *, -, ...)
    else if (isUnaryToken(current()))
      to_ret = parse_unary();
    // Handles (...)
    else if (current() == TKN_LEFT_PAREN)
      to_ret = parse_parenthesis(&ASTMaker::parse_binary);
    // Handles invalid primary expressions
    else
      to_ret = parse_primary_invalid(range);    

    //If the primary expression accepts a conversion, check for as/bit_as.
    if (accepts_conv && is_current_one_of(TKN_KEYWORD_bit_as, TKN_KEYWORD_as))
      return parse_conversion(to_ret, range);
    return to_ret;
  }

  ProdExprToken ASTMaker::parse_unary_and(ProdExprToken child, const TokenRangeGenerator& range) noexcept
  {
    if (auto pchild = decl_from_read(child); pchild.isValue())
      return Expr().addAddressOf(range.getRange(), pchild.getValue());

    report<ERROR>(range.getRange(), nullptr,
      "Unary '&' can only be applied on a variable!");
    return Expr().addError(range.getRange());
  }

  ProdExprToken ASTMaker::parse_unary_star(ProdExprToken child, const TokenRangeGenerator& range) noexcept
  {
    if (!Type(child).isAnyOpaquePtr())
    {
      report<ERROR>(range.getRange(), nullptr,
        "Unary '*' can only be applied on a non-opaque pointer!");
      return Expr().addError(range.getRange());
    }
    else if (!Type(child).isAnyPtr())
    {
      report<ERROR>(range.getRange(), nullptr,
        "Unary '*' can only be applied on pointer types!");
      return Expr().addError(range.getRange());
    }
    return Expr().addPtrLoad(range.getRange(), child);
  }  

  ProdExprToken ASTMaker::parse_unary()
  {
    assert_true("parse_unary must be called when a unary token is hit!", isUnaryToken(current()));
    using enum Lexeme;
    auto depth = addDepth();
    auto range = startRange();

    uninit<ProdExprToken> to_ret;

    //Save the operator
    Token op = current();
    consume_current(); //consume the unary operator

    //Parse the child expression, without handling conversions:
    // '-5 as i32' is equivalent to '(-5) as i32'
    ProdExprToken child = parse_primary(false);
    if (Expr(child).isError())
      return child;

    switch (op)
    {
    case TKN_PLUS_PLUS:
    case TKN_MINUS_MINUS:
      
      // Handles '+', which are not supported by the language
    break; case TKN_PLUS:
      report<ERROR>(range.getRange(), current_panic, "Unary '+' is not supported!");
      to_ret = Expr().addError(range.getRange());
      
      // Handles '&', which are usually AddressOf expressions
    break; case TKN_AND:    
      to_ret = parse_unary_and(child, range);    
      
      // Handles '*', which are usually PtrLoad expressions
    break; case TKN_STAR:
      to_ret = parse_unary_star(child, range);
    
      // Handles the rest of the unary tokens (makeUnary checks for supports())
    break; default:
      to_ret = makeUnary(range.getRange(), TokenToUnary(op), child);      
    }
    return to_ret;
  }

  ProdExprToken ASTMaker::parse_binary()
  {
    using enum Lexeme;
    auto depth = addDepth();
    auto range = startRange();

    ProdExprToken lhs = parse_primary();
    if (Expr(lhs).isError())
    {
      panic_consume();
      return lhs;
    }

    // The binary operators
    Token binary_op = current();
    if (isAssignmentToken(binary_op))
      return parse_assignment(lhs, range);
    if (isComparisonToken(binary_op))
    {
      lhs = parse_comparison(binary_op, lhs, range);
      binary_op = current();
    }

    const u8 precedence = 0;
    //The current operator's precedence
    u8 op_precedence = OpPrecedence(binary_op);
    while (op_precedence > precedence)
    {
      //Consume the operator
      consume_current();
      //Recurse: 10 + 5 + 8 -> (10 + (5 + 8))
      ProdExprToken rhs = parse_binary_internal(binary_op, false);
      if (Expr(rhs).isError())
        return rhs;

      if (!isBinaryToken(binary_op))
      {
        report<report_as::ERROR>(binary_op, current_panic, "Expected a binary operator!");
        return Expr().addError(range.getRange());
      }
      //Pratt's parsing, which allows operators priority
      lhs = makeBinary(range.getRange(), lhs, TokenToBinary(binary_op), rhs);
      if (isComparisonToken(current()))
        lhs = parse_comparison(current(), lhs, range);

      //Update the Token
      binary_op = current();
      //Update precedence
      op_precedence = OpPrecedence(binary_op);
    }

    return lhs;
  }

  ProdExprToken ASTMaker::parse_binary_internal(Token previous, bool is_parsing_comp)
  {
    using enum Lexeme;
    auto depth = addDepth();
    auto range = startRange();

    ProdExprToken lhs = parse_primary();
    if (Expr(lhs).isError())
    {
      panic_consume();
      return lhs;
    }

    // The binary operators
    Token binary_op = current();
    //The current operator's precedence
    u8 op_precedence = OpPrecedence(binary_op);
    while (op_precedence > OpPrecedence(previous))
    {
      //Consume the operator
      consume_current();
      //Recurse: 10 + 5 + 8 -> (10 + (5 + 8))
      ProdExprToken rhs = parse_binary_internal(binary_op);
      if (Expr(rhs).isError())
        return rhs;

      if (!isBinaryToken(binary_op))
      {
        report<report_as::ERROR>(binary_op, current_panic, "Expected a binary operator!");
        return Expr().addError(range.getRange());
      }
      else if (isComparisonToken(binary_op))
        lhs = is_parsing_comp ? lhs : parse_comparison(binary_op, lhs, range);
      else //Pratt's parsing, which allows operators priority
        lhs = makeBinary(range.getRange(), lhs, TokenToBinary(binary_op), rhs);

      //Update the Token
      binary_op = current();
      //Update precedence
      op_precedence = OpPrecedence(binary_op);
    }

    return lhs;
  }

  ProdExprToken ASTMaker::parse_conversion(ProdExprToken to_conv, const TokenRangeGenerator& range)
  {
    using enum Lexeme;
    auto depth = addDepth();
    assert_true("Function should only be called when 'as' or 'bit_as' is encountered!",
      current() == TKN_KEYWORD_as || current() == TKN_KEYWORD_bit_as);

    auto cnv = current();
    consume_current();

    TypeToken cnv_type = parse_typename();
    if (Type(cnv_type).isError())
      return Expr().addError(range.getRange());
    if (Expr(to_conv).isError())
      return to_conv;

    // A bit_as conversion must have either the target or the starting
    // type be a byte type
    if (cnv == TKN_KEYWORD_bit_as
      && !(Type(cnv_type).isBuiltinAnd(&isBytes) || Type(to_conv).isBuiltinAnd(&isBytes)))
    {
      report<report_as::ERROR>(range.getRange(), nullptr,
        "'bit_as' conversion can only be applied on/to bytes types!");
      getReporter().message("Bytes types are 'BYTE', 'WORD', 'DWORD' and 'QWORD'.");
      return Expr().addError(range.getRange());
    }

    return makeCast(range.getRange(), to_conv, cnv_type, cnv == TKN_KEYWORD_bit_as);
  }

  ProdExprToken ASTMaker::parse_assignment(ProdExprToken assign_to, const TokenRangeGenerator& range)
  {
    auto panic = scopedSetPanic(&ASTMaker::panic_consume_semicolon);
    return assign_to;
  }

  enum class ComparisonSet
  {
    /// @brief {<, <=}
    LE_OR_LEQ,
    /// @brief ==
    EQUAL,
    /// @brief {>, >=}
    GE_OR_GEQ,
    /// @brief !=
    NONE
  };

  ProdExprToken ASTMaker::parse_comparison(Token comparison, ProdExprToken lhs, const TokenRangeGenerator& range)
  {
    using enum Lexeme;
    using enum ComparisonSet;
    assert_true("parse_comparison must be called when isComparisonToken(current())", isComparisonToken(comparison));
    
    ComparisonSet comparison_set = NONE;
    if (comparison == TKN_EQUAL_EQUAL)
      comparison_set = EQUAL;
    else if (comparison == TKN_LESS || comparison == TKN_LESS_EQUAL)
      comparison_set = LE_OR_LEQ;
    else if (comparison == TKN_GREAT || comparison == TKN_GREAT_EQUAL)
      comparison_set = GE_OR_GEQ;
    consume_current();
    parse_binary_internal(comparison);
    
    return lhs;
  }

  TypeToken ASTMaker::parse_typename() noexcept
  {
    using enum Lexeme;

    //Save current expression state
    auto depth = addDepth();
    auto range = startRange();

    // typeof(10 + 5) -> type of (10 + 5)
    if (current() == TKN_KEYWORD_typeof)
    {
      consume_current();
      return Expr(parse_parenthesis(&ASTMaker::parse_binary)).getType();
    }

    if (current() == TKN_KEYWORD_void)
    {
      consume_current(); //void
      return Type().getVoidType();
    }
    if (isBuiltinToken(current()))
    {
      auto type = current();
      consume_current();
      return Type().addBuiltin(KeywordToBuiltinID(type));
    }
    if (current() == TKN_KEYWORD_opaque)
    {
      consume_current();
      return Type().addOpaquePtr();
    }
    if (current() == TKN_KEYWORD_mut_opaque)
    {
      consume_current();
      return Type().addMutOpaquePtr();
    }
    if (current() == TKN_KEYWORD_ptr || current() == TKN_KEYWORD_mut_ptr)
    {
      bool is_mut = current() == TKN_KEYWORD_mut_ptr;
      consume_current();
      
      if (check_consume(TKN_GREAT, current_panic, "Expected a '>'!").is_success())
      {
        auto ptr_to = parse_typename();
        if (Type(ptr_to).isError())
          return ptr_to;
        return is_mut ? Type().addMutPtr(ptr_to) : Type().addPtr(ptr_to);
      }
      return Type().getErrorType();
    }
    report<report_as::ERROR>(range.getRange(), current_panic,
      "Expected a typename!");
    return Type().getErrorType();
  }

  OptTok<StmtExprToken> ASTMaker::decl_from_read(ProdExprToken expr) const noexcept
  {
    auto& read = Expr(expr);
    if (!read.isRead())
      return None;
    return read.as<ReadExpr>()->getDecl();
  }

  ProdExprToken ASTMaker::makeBinary(TokenRange range, ProdExprToken lhs, BinaryOp op, ProdExprToken rhs) noexcept
  {
    using enum BinarySupport;
    
    if (Expr(lhs).isError() || Expr(rhs).isError())
      return Expr().addError(range);

    auto& type = Type(lhs);
    auto support = type.supports(op, Type(rhs));    
    switch_no_default(support)
    {
    case BUILTIN:
      // If the right hand side of the expression is a literal,
      // then we can check for division by zero.
      // If the left hand side is also a literal, we can constant fold
      // the expression
      if (auto rhs_p = Expr(rhs).as<LiteralExpr>();
        rhs_p != nullptr)
      {
        if (auto lhs_p = Expr(lhs).as<LiteralExpr>())
          return constantFold(range, *lhs_p, op, *rhs_p);
        if ((op == BinaryOp::OP_DIV || op == BinaryOp::OP_MOD) && isLiteralZero(rhs))
        {
          report<report_as::ERROR>(range, nullptr, "Integral division by zero is not allowed!");
          return Expr().addError(range);
        }
      }
      return Expr().addBinary(range, lhs, op, rhs);
    
    case INVALID_OP:
      report<report_as::ERROR>(range, nullptr,
        "'{}' does not support operator '{}'!",
        getTypeName(type), toStr(op));
      return Expr().addError(range);
    
    case INVALID_TYPE:
      report<report_as::ERROR>(range, nullptr,
        "'{}' does not support '{}' as right hand side of operator '{}'!",
        getTypeName(type), getTypeName(Type(rhs)), toStr(op));
      return Expr().addError(range);
    }
  }

  ProdExprToken ASTMaker::makeUnary(TokenRange range, UnaryOp op, ProdExprToken child) noexcept
  {
    using enum UnarySupport;
    
    if (Expr(child).isError())
      return Expr().addError(range);

    auto& type = Type(child);
    auto support = type.supports(op);
    
    switch_no_default(support)
    {
    case BUILTIN:
      if (auto ptr = Expr(child).as<LiteralExpr>(); ptr != nullptr)
        return constantFold(range, op, *ptr);
      return Expr().addUnary(range, op, child);
    case INVALID:
      report<report_as::ERROR>(range, current_panic,
        "'{}' does not support unary operator '{}'!",
        getTypeName(type), toStr(op));
      return Expr().addError(range);
    }
  }

  ProdExprToken ASTMaker::makeCast(TokenRange range, ProdExprToken to_cast, TypeToken to, bool is_bit_cast) noexcept
  {
    if (is_bit_cast)
    {
      unreachable("Not implemented!");
      return Expr().addError(range);
    }
    auto builtin_t = Type(to).as<BuiltinType>();
    if (auto ptr = Expr(to_cast).as<LiteralExpr>(); ptr != nullptr && builtin_t != nullptr)
      return constantFold(range, *ptr, *builtin_t);
    return Expr().addCast(range, to, to_cast);
  }

  run::TypeOp BuiltinToTypeOp(BuiltinID ID) noexcept
  {
    using enum clt::run::TypeOp;

    static constexpr std::array ID_to_type =
    {
      u8_t, u8_t,
      u8_t, u16_t, u32_t, u64_t,
      i8_t, i16_t, i32_t, i64_t,
      f32_t, f64_t,
      u8_t, u16_t, u32_t, u64_t,
    };
    return ID_to_type[(u8)ID];
  }

  ProdExprToken ASTMaker::constantFold(TokenRange range, const LiteralExpr& lhs, BinaryOp op, const LiteralExpr& rhs) noexcept
  {

    static constexpr std::array table =
    {
      &run::NT_add, &run::NT_sub, &run::NT_mul, &run::NT_div, &run::NT_mod,
      &run::NT_bit_and, &run::NT_bit_or, &run::NT_bit_xor, &run::NT_shl, &run::NT_shr,
      &run::NT_bit_and, &run::NT_bit_or,
      &run::NT_le, &run::NT_leq, &run::NT_ge, &run::NT_geq, &run::NT_neq, &run::NT_eq
    };

    
    assert_true("Expected built-in type!", Type(lhs).as<BuiltinType>() != nullptr, Type(rhs).as<BuiltinType>() != nullptr);
    const auto typeID = Type(lhs).as<BuiltinType>()->typeID();

    auto fn = table[static_cast<u8>(op)];
    auto [res, err] = fn(lhs.getValue(), rhs.getValue(),
      BuiltinToTypeOp(typeID));

    if (err == run::DIV_BY_ZERO)
    {
      report<report_as::ERROR>(range, nullptr,
        "Integral division by zero is not allowed!");
      return Expr().addError(range);
    }
    else if (warnFor(err))
    {
      report<report_as::WARNING>(range, nullptr,
        "{}", run::toExplanation(err));
    }

    const auto family = FamilyOf(op);
    // If this is true then the resulting expression is a boolean
    const bool is_ret_bool = family == OpFamily::BOOL_LOGIC || family == OpFamily::COMPARISON;

    return Expr().addLiteral(range, res,
      is_ret_bool ? BuiltinID::BOOL : typeID
    );
  }

  ProdExprToken ASTMaker::constantFold(TokenRange range, UnaryOp op, const LiteralExpr& lhs) noexcept
  {
    using enum clt::lng::UnaryOp;

    switch_no_default (op)
    {
    case OP_NEGATE:
    {
      const auto ID = Type(lhs).as<BuiltinType>()->typeID();
      auto [result, err] = run::NT_neg(lhs.getValue(), BuiltinToTypeOp(ID));
      if (warnFor(err))
        report<report_as::WARNING>(range, nullptr, "{}", run::toExplanation(err));
      return Expr().addLiteral(range, result, ID);
    }
    case OP_BOOL_NOT:
    {
      // No errors are possible
      auto [result, err] = run::bool_not(lhs.getValue());
      return Expr().addLiteral(range, result, BuiltinID::BOOL);
    }
    case OP_BIT_NOT:
    {
      // No errors are possible
      const auto ID = Type(lhs).as<BuiltinType>()->typeID();
      auto [result, err] = run::NT_bit_not(lhs.getValue(), BuiltinToTypeOp(ID));
      return Expr().addLiteral(range, result, ID);
    }
    }
  }

  ProdExprToken ASTMaker::constantFold(TokenRange range, const LiteralExpr& to_conv, const BuiltinType& to) noexcept
  {
    auto [result, err] = run::NT_cnv(to_conv.getValue(),
      BuiltinToTypeOp(Type(to_conv).as<BuiltinType>()->typeID()), BuiltinToTypeOp(to.typeID()));
    if (warnFor(err))
      report<report_as::WARNING>(range, nullptr, "{}", run::toExplanation(err));
    return Expr().addLiteral(range, result, to.typeID());
  }

  bool ASTMaker::isLiteralZero(ProdExprToken expr) const noexcept
  {
    return Type(expr).isBuiltinAnd(&isIntegral)
      && Expr(expr).as<LiteralExpr>()->getValue().is_none_set();
  }

  void PrintExpr(ProdExprToken tkn, const ParsedUnit& unit, u64 depth) noexcept
  {
    using enum clt::lng::ExprID;
    auto& buffer = unit.getExprBuffer();
    auto& types = unit.getProgram().getTypes();
    auto& tkn_buffer = unit.getTokenBuffer();    
    auto& expr = buffer.getExpr(tkn);
    
    auto info = tkn_buffer.makeSourceInfo(expr.getTokenRange());
    switch (expr.classof())
    {
    break; case EXPR_ERROR:
      io::print("{}{:^{}}({:h}: {}){}", io::BrightRedF, "", depth * 3, expr.classof(), info.expr, io::Reset);
    
    break; case EXPR_LITERAL:
      io::print("{}{:^{}}({:h}: {}, {} {}){}", io::BrightGreenF, "", depth * 3, expr.classof(),
        info.expr, fmt_TypedQWORD{ expr.as<LiteralExpr>()->getValue(), types.getType(expr.getType()).as<BuiltinType>()->typeID() },
        types.getTypeName(expr.getType()), io::Reset);
    
    break; case EXPR_UNARY:
      io::print("{}{:^{}}({:h}: '{:h}'", io::YellowF, "", depth * 3, expr.classof(),
        expr.as<UnaryExpr>()->getOp());
      PrintExpr(expr.as<UnaryExpr>()->getExpr(), unit, depth + 1);
      io::print("{}{:^{}}{}){}", io::YellowF, "", depth * 3, types.getTypeName(expr.getType()), io::Reset);

    break; case EXPR_BINARY:
      io::print("{}{:^{}}({:h}:", io::BrightCyanF, "", depth * 3, expr.classof());
      PrintExpr(expr.as<BinaryExpr>()->getLHS(), unit, depth + 1);
      io::print("{}{:^{}} {:h}", io::BrightCyanF, "", depth * 3,
        expr.as<BinaryExpr>()->getOp());
      PrintExpr(expr.as<BinaryExpr>()->getRHS(), unit, depth + 1);
      io::print("{}{:^{}}{}){}", io::BrightCyanF, "", depth * 3, types.getTypeName(expr.getType()), io::Reset);
    
    break; case EXPR_CAST:
      io::print("{}{:^{}}({:h}: '{}' -> '{}'", io::BrightMagentaF, "", depth * 3, expr.classof(),
        types.getTypeName(expr.as<CastExpr>()->getType()), types.getTypeName(expr.as<CastExpr>()->getTypeToCastTo()));
      PrintExpr(expr.as<CastExpr>()->getToCast(), unit, depth + 1);
      io::print("{}{:^{}}{}){}", io::BrightMagentaF, "", depth * 3, types.getTypeName(expr.as<CastExpr>()->getType()), io::Reset);
    
    break; default:
      io::print("{:^{}}{:h}", "", depth * 3, expr.classof());
      break;
    }
  }
}