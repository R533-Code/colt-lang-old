#include "ast.h"

namespace clt::lng
{
  void MakeAST(ParsedUnit& unit) noexcept
  {

  }

  ProdExprToken ASTMaker::parse_primary(bool accepts_conv)
  {
    using enum Lexeme;
    auto range = startRange();

    uninit<ProdExprToken> to_ret;

    if (isLiteralToken(current()))
    {
      //Save literal token
      auto literal_tkn = current();

      //TODO: add support for string literal
      QWORD_t value = getTokenBuffer().getLiteral(literal_tkn);
      //Consume the literal token
      consume_current();
      to_ret.init(
        getExprBuffer().addLiteral(range.getRange(), value, LiteralToBuiltinID(literal_tkn))
      );
    }
    else if (isUnaryToken(current()))
      to_ret.init(parse_unary());
    else if (current() == TKN_LEFT_PAREN)
      to_ret.init(parse_parenthesis(&ASTMaker::parse_binary, as<u8>(0)));
    else if (current() == TKN_IDENTIFIER)
    {
      to_ret = parse_identifier(line_state);
      if (is_a<WhileLoopExpr>(to_ret))
        return to_ret;
    }
    else
    {
      // The error would have been generated by the lexer
      if (current() == TKN_ERROR)
        consume_current();
      else
        generate_current<ERROR>(&ASTMaker::panic_consume_semicolon,
          "Expected an expression!"); //TESTED
      to_ret = Expr::CreateError(ctx, line_state.to_src_info());
    }

    //If the primary expression accepts a conversion, check for as/bit_as.
    if (cnv && (current_tkn == TKN_KEYWORD_AS || current_tkn == TKN_KEYWORD_BIT_AS))
      return parse_conversion(to_ret, line_state);
    return to_ret;
  }
}